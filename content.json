{"meta":{"title":"奥利给！干了兄弟们！","subtitle":null,"description":null,"author":"Nie Cong","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"3.14更新","slug":"destiny-child-3-14","date":"2019-03-15T06:28:28.000Z","updated":"2019-04-04T05:56:34.556Z","comments":true,"path":"2019/03/15/destiny-child-3-14/","link":"","permalink":"http://yoursite.com/2019/03/15/destiny-child-3-14/","excerpt":"","text":"3.14更新child dana火属性回复型 ？？水属性妨害型 main event narrative每天无限次挑战，最高难度终章消耗34体力。奖励：五星A级武器，五星天命劵，五星A级防具，五星 收集奖励： other3.21更新other 捡垃圾收集樱花标记，每天10个，共100个，最终奖励：彼岸之花 3.28更新child 火属性辅助型， 木属性攻击性 main event world boss木属性攻击性，攻击附带气绝效果，暴击高 award 候补生应援7天签到补给，最终奖励：五星天命劵，五星卡升级劵 summon","categories":[],"tags":[{"name":"destiny child","slug":"destiny-child","permalink":"http://yoursite.com/tags/destiny-child/"}]},{"title":"propagation事务","slug":"propagation","date":"2019-03-14T10:49:56.000Z","updated":"2019-03-15T03:50:04.218Z","comments":true,"path":"2019/03/14/propagation/","link":"","permalink":"http://yoursite.com/2019/03/14/propagation/","excerpt":"","text":"propagation 事务的传播特性我们都知道事务的概念，那么事务的传播特性是什么呢？(此处着重介绍传播特性的概念，关于传播特性的相关配置就不介绍了，可以查看spring的官方文档) 在我们用SSH开发项目的时候，我们一般都是将事务设置在Service层 那么当我们调用Service层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。 如果你在你的Service层的这个方法中，除了调用了Dao层的方法之外，还调用了本类的其他的Service方法，那么在调用其他的Service方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里掉用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的，“事务是会传播的”在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。 以前没有Spring帮助我们完成事务的时候我们必须自己手动的控制事务，例如当我们项目中仅仅使用hibernate，而没有集成进spring的时候，我们在一个service层中调用其他的业务逻辑方法，为了保证事物必须也要把当前的hibernate session传递到下一个方法中，或者采用ThreadLocal的方法，将session传递给下一个方法，其实都是一个目的。现在这个工作由spring来帮助我们完成，就可以让我们更加的专注于我们的业务逻辑。而不用去关心事务的问题。 默认情况下当发生RuntimeException的情况下，事务才会回滚，所以要注意一下 如果你在程序发生错误的情况下，有自己的异常处理机制定义自己的Exception，必须从RuntimeException类继承 这样事务才会回滚！ 事务的传播行为和隔离级别[transaction behavior and isolated level]key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。 接口定义12345678910111213int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; 例子12345678910ServiceA &#123; void methodA() &#123; ServiceB.methodB(); &#125; &#125; ServiceB &#123; void methodB() &#123; &#125; &#125; 说明1： PROPAGATION_REQUIRED加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务。比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚。 2： PROPAGATION_SUPPORTS如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行这就跟平常用的普通非事务的代码只有一点点区别了。不理这个，因为我也没有觉得有什么区别 3： PROPAGATION_MANDATORY必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常。 4： PROPAGATION_REQUIRES_NEW这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA捕，ServiceA.methodA事务仍然可能提交。 5： PROPAGATION_NOT_SUPPORTED当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。 6： PROPAGATION_NEVER不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。 7： PROPAGATION_NESTED理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。而Nested事务的好处是他有一个savepoint。 12345678910ServiceA &#123; void methodA() &#123; try &#123; //savepoint ServiceB.methodB(); //PROPAGATION_NESTED 级别 &#125; catch (SomeException) &#123; // 执行其他业务, 如 ServiceC.methodC(); &#125; &#125; &#125; 也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如ServiceC.methodC，继续执行，来尝试完成自己的事务。但是这个事务并没有在EJB标准中定义。 Isolation Level(事务隔离等级)1、Serializable：最严格的级别，事务串行执行，资源消耗最大； 2、REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。 3、READ COMMITTED:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。 4、Read Uncommitted：保证了读取过程中不会读取到非法数据。 隔离级别在于处理多事务的并发问题。我们知道并行可以提高数据库的吞吐量和效率，但是并不是所有的并发事务都可以并发运行，这需要查看数据库教材的可串行化条件判断了。这里就不阐述。我们首先说并发中可能发生的3中不讨人喜欢的事情1：Dirty reads–读脏数据。也就是说，比如事务A的未提交（还依然缓存）的数据被事务B读走，如果事务A失败回滚，会导致事务B所读取的的数据是错误的。 2：non-repeatable reads–数据不可重复读。比如事务A中两处读取数据-total-的值。在第一读的时候，total是100，然后事务B就把total的数据改成200，事务A再读一次，结果就发现，total竟然就变成200了，造成事务A数据混乱。 3：phantom reads–幻象读数据。这个和non-repeatable reads相似，也是同一个事务中多次读不一致的问题。但是non-repeatable reads的不一致是因为他所要取的数据集被改变了（比如total的数据），但是phantom reads所要读的数据的不一致却不是他所要读的数据集改变，而是他的条件数据集改变。比如Select account.id where account.name=”ppgogo*”,第一次读去了6个符合条件的id，第二次读取的时候，由于事务b把一个帐号的名字由”dd”改成”ppgogo1”，结果取出来了7个数据。 dirty reads non-repeatable reads phantom reads Serializable N N N Repeatable Read N N Y Read Committed N Y Y Read Uncommitted Y Y Y","categories":[],"tags":[{"name":"事务","slug":"事务","permalink":"http://yoursite.com/tags/事务/"}]},{"title":"md文件编辑","slug":"mdFile","date":"2019-03-07T09:34:52.000Z","updated":"2019-03-07T09:35:35.873Z","comments":true,"path":"2019/03/07/mdFile/","link":"","permalink":"http://yoursite.com/2019/03/07/mdFile/","excerpt":"","text":"md语法What?make it real? bullet pointbold test [to do?]link:http://www.baidu.com 快捷输入方式只需要输入如下内容, Atom编辑器会自动提示，回车之后即可进入对应的状态。 加粗文字 : btest 代码: c 1test 斜体: itest 图像: img 链接: lwww.baidu.com 权声明: legalCopyright (c) 2018 Copyright Holder All Rights Reserved. 填充文字: loremLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 引用编号代码格式:ref 外联引用指定编号的链接: rl 外联引用指定编号图片: rimg todo列表 :t [ test ] 表格： table t1 t2 nice I3 I5 ??? 文件名 大小（单位：字节） art.tar.gz 6.0M bionic.tar.gz 3.7M bootable.tar.gz 18M build.tar.gz 3.1M cts.tar.gz 381M dalvik.tar.gz 1.2M developers.tar.gz 277M development.tar.gz 90M device.tar.gz 168M docs.tar.gz 28M external.tar.gz 1.5G frameworks.tar.gz 918M hardware.tar.gz 40M kernel.tar.gz 81K libcore.tar.gz 10M libnativehelper.tar.gz 29K makefile.tar.gz 243 packages.tar.gz 144M pdk.tar.gz 149K platform_testing.tar.gz 395K prebuilts.tar.gz 7.9G sdk.tar.gz 6.9M system.tar.gz 196M test.tar.gz 3.4M toolchain.tar.gz 29M tools.tar.gz 1.4G 123function good()&#123; system.out.println(&quot;/&quot;);&#125;","categories":[],"tags":[]},{"title":"图片测试","slug":"picTest","date":"2019-03-07T08:53:33.000Z","updated":"2019-03-07T09:00:27.315Z","comments":true,"path":"2019/03/07/picTest/","link":"","permalink":"http://yoursite.com/2019/03/07/picTest/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"文章发布","slug":"Intro","date":"2019-03-07T06:11:31.000Z","updated":"2019-03-15T03:41:50.651Z","comments":true,"path":"2019/03/07/Intro/","link":"","permalink":"http://yoursite.com/2019/03/07/Intro/","excerpt":"","text":"发布文章流程新建文章终端cd到blog文件夹下，执行如下命令新建文章：1$ hexo new \"postName\" 名为postName.md的文件会建在目录/blog/source/_posts下，postName是文件名，为方便链接不建议掺杂汉字。我在用MacDown编辑器，支持预览。 注意：当你的博文写多了之后，在写新的文章的时候就要在_post里面来找到你新建的文章，比较麻烦，现在可以让你在用了命令 $ hexo new “postName”之后自动打开 修改文章完成上传 文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布： 123$ hexo generate //生成静态页面$ hexo deploy //将文章部署到Github","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}